## Advanced Custom hook.

Filtering is a functionality provided by our app. It has related state and could also be useful if our app had other types of data in lists, e.g. list of actors, list of TV series. We could encapsulate this logic in a custom hook. The hook need to be generic - it should deal with different data types. The hook's inputs will include:
+ The data list to be filtered.
+ The set of filters to apply to the data. Each filter will declare:
   1. The initial value for the filter. The user can chage this, which will cause the hook to re-execute.
   1. The condition that expresses how the filter value is used to determine which parts of the data list are included in the result.
The hook returns:
+ The current filter values
+ A setter method to change the filter values.
+ A function that a component can call to perform the filtering. This function is dynamically computed by the hook.



Create the file `src/hooks/useFiltering.js` and add the following code:
~~~
import { useState } from "react";

const useFiltering = (data, filters) => {
  const [filterValues, setFilterValues] = useState(() => {
    const filterInitialValues = filters.map((f) => ({
      name: f.name,
      value: f.value,
    }));
    return filterInitialValues;
  });

  const filteringConditions = filters.map((f) => f.condition);
  const filterFunction = (collection) =>
    filteringConditions.reduce((data, conditionFn, index) => {
      return data.filter((item) => {
        return conditionFn.call(filterValues[index], item);
      });
    }, collection);

  return {
    filterValues,
    setFilterValues,
    filterFunction,
  };
};

export default useFiltering;

~~~` 